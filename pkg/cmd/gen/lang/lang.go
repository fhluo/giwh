package lang

import (
	"bytes"
	_ "embed"
	. "github.com/dave/jennifer/jen"
	"github.com/dop251/goja"
	"github.com/mitchellh/mapstructure"
	"github.com/samber/lo"
	"github.com/spf13/cobra"
	"golang.org/x/exp/slices"
	"golang.org/x/exp/slog"
	"golang.org/x/text/language"
	"golang.org/x/text/language/display"
	"os"
	"regexp"
)

const pkgLang = "golang.org/x/text/language"

var (
	//go:embed language.js
	langJS string

	//go:embed language.go
	languageGo []byte

	languages []Language

	log = slog.With("gen lang")
)

func init() {
	vm := goja.New()

	v, err := vm.RunString(langJS)
	if err != nil {
		log.Error(err.Error(), nil)
		os.Exit(1)
	}

	err = mapstructure.Decode(v.Export(), &languages)
	if err != nil {
		log.Error(err.Error(), nil)
		os.Exit(1)
	}
}

func NewCmd() *cobra.Command {
	var packageName string

	cmd := &cobra.Command{
		Use:   "lang",
		Short: "Generate i18n/languages.go",
		RunE: func(cmd *cobra.Command, args []string) error {
			file := NewFile(packageName)
			file.HeaderComment("Code generated by `giwh gen lang`. DO NOT EDIT.")
			file.ImportName(pkgLang, "language")

			file.Add(LanguagesDefs())
			file.Add(Languages())
			file.Add(Supported())

			file.Var().Id("Matcher").Op("=").Qual(pkgLang, "NewMatcher").Call(
				Id("Supported"),
			)

			buffer := bytes.NewBuffer(nil)
			if err := file.Render(buffer); err != nil {
				return err
			}

			if err := os.WriteFile("languages.go", buffer.Bytes(), 0666); err != nil {
				return err
			}

			buffer = bytes.NewBufferString("// Code generated by `giwh gen lang`. DO NOT EDIT.\n\n")
			buffer.WriteString("package " + packageName)
			buffer.Write(bytes.TrimPrefix(languageGo, []byte("package lang")))

			if err := os.WriteFile("language.go", buffer.Bytes(), 0666); err != nil {
				return err
			}

			return nil
		},
	}

	cmd.Flags().StringVarP(&packageName, "pkg", "p", "i18n", "package name")

	return cmd
}

func (lang Language) VarName() string {
	return regexp.MustCompile(`\s`).ReplaceAllString(display.English.Languages().Name(lang.Tag()), "")
}

func (lang Language) ParentVarName() string {
	return regexp.MustCompile(`\s`).ReplaceAllString(display.English.Languages().Name(lang.Parent()), "")
}

func LanguagesDefs() Code {
	return Var().Defs(lo.Map(languages, func(lang Language, _ int) Code {
		return Id(lang.ParentVarName()).Op("=").Id("Language").Values(Dict{
			Id("Key"):   Lit(lang.Key),
			Id("Name"):  Lit(lang.Name),
			Id("Short"): Lit(lang.Short),
		})
	})...).Line()
}

func Languages() Code {
	return Var().Id("Languages").Op("=").Index().Id("Language").Add(
		Op("{").Line().Add(
			lo.Map(languages, func(lang Language, _ int) Code {
				return Id(lang.ParentVarName()).Op(",").Comment(lang.CanonicalKey()).Line()
			})...,
		).Op("}"),
	).Line()
}

func Supported() Code {
	i := slices.IndexFunc(languages, func(lang Language) bool {
		return lang.CanonicalKey() == language.AmericanEnglish.String()
	})
	if i == -1 {
		slog.Error("Could not find the specified language", nil, "language", language.AmericanEnglish)
		os.Exit(1)
	}
	supported := make([]Language, 0, len(languages))
	supported = append(supported, languages[i])
	supported = append(supported, languages[:i]...)
	supported = append(supported, languages[i+1:]...)

	return Var().Id("Supported").Op("=").Index().Qual(pkgLang, "Tag").Add(
		// Using the function Values or Custom does not render correctly.
		Op("{").Line().Add(
			lo.Map(supported, func(lang Language, _ int) Code {
				return Qual(pkgLang, lang.VarName()).Op(",").Comment(lang.Tag().String()).Line()
			})...,
		).Op("}"),
	).Line()
}
